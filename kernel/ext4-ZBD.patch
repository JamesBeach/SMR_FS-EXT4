diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
old mode 100644
new mode 100755
index f63c3d5..8422719
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -297,7 +297,9 @@ struct ext4_group_desc
 	__le32  bg_exclude_bitmap_hi;   /* Exclude bitmap block MSB */
 	__le16  bg_block_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+bbitmap) BE */
 	__le16  bg_inode_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+ibitmap) BE */
-	__u32   bg_reserved;
+	__u8   bg_zone_type; /*Specify Zone type for ZBD drives.  Should be aligned to BGs*/
+	__u8   bg_zone_condition; /*Specify Zone condiion for ZBD devices. */
+	__le16  bg_reserved;
 };
 
 #define EXT4_BG_INODE_BITMAP_CSUM_HI_END	\
@@ -604,6 +606,11 @@ enum {
 #define EXT4_IOC_SWAP_BOOT		_IO('f', 17)
 #define EXT4_IOC_PRECACHE_EXTENTS	_IO('f', 18)
 
+/* seagate: report zones: T13 -> 0x4A: REPORT_ZONES */
+#define EXT4_IOC_REPORT_ZONES       	_IOWR('f', 19, struct bdev_zone_report_ioctl_t)
+#define EXT4_IOC_RESET_WP       	_IO('f', 20)
+#define EXT4_IOC_INQUIRY       	_IOWR('f', 21, struct zoned_inquiry)
+
 #if defined(__KERNEL__) && defined(CONFIG_COMPAT)
 /*
  * ioctl commands in 32 bit emulation
@@ -1005,6 +1012,8 @@ struct ext4_inode_info {
 						      blocks */
 #define EXT4_MOUNT2_HURD_COMPAT		0x00000004 /* Support HURD-castrated
 						      file systems */
+#define EXT4_MOUNT2_DISK_SMR	0x00000008 /* Support for SMR based Disks */
+#define EXT4_MOUNT2_DISK_ZONE   0x00000010 /* Support for Zone-based disks - Host Aware/Host Managed*/
 
 #define clear_opt(sb, opt)		EXT4_SB(sb)->s_mount_opt &= \
 						~EXT4_MOUNT_##opt
@@ -1169,6 +1178,7 @@ struct ext4_super_block {
 	__le32	s_overhead_clusters;	/* overhead blocks/clusters in fs */
 	__le32	s_backup_bgs[2];	/* groups with sparse_super2 SBs */
 	__u8	s_encrypt_algos[4];	/* Encryption algorithms in use  */
+	__le32  s_disk_layout; 		/*Disk format (Conv, SMR, ZBD)*/
 	__le32	s_reserved[105];	/* Padding to the end of the block */
 	__le32	s_checksum;		/* crc32c(superblock) */
 };
@@ -1351,6 +1361,10 @@ struct ext4_sb_info {
 	struct ratelimit_state s_err_ratelimit_state;
 	struct ratelimit_state s_warning_ratelimit_state;
 	struct ratelimit_state s_msg_ratelimit_state;
+
+   /* Media Information - ZBD devices */
+   unsigned int ext4_forward_write;
+   unsigned int ext4_ZBD_info;
 };
 
 static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)
@@ -1871,6 +1885,35 @@ struct ext4_features {
 	struct completion f_kobj_unregister;
 };
 
+
+/*
+ * Structures for SMR/ZBD drives.  These remove disk agnosticism!
+ * These are flags that *temporarily* add a code path,
+ * and add several conditional functions.
+ * The code path can replace the standard path in the future.
+*/
+
+enum ext4_drive_behavior{
+	ext4_drive_Conventional = 0,	/* Conventional write in place */
+	ext4_drive_Forward_Write = 1,	/* Bit 0 - Strict Forward write requirement */
+	ext4_drive_Zone_Info = 2,	/* Bit 1 - Zone status over interface */
+   ext4_drive_Zone_Strict = 4, /* Bit 2 - Zone behavior strict*/
+};
+
+#define DRIVE_PMR ext4_drive_Conventional
+#define DRIVE_SMR ext4_drive_Forward_Write
+#define DRIVE_SMR_DM drive_PMR
+#define DRIVE_SMR_HA (ext4_drive_Forward_Write|ext4_drive_Zone_Info)
+#define DRIVE_SMR_HM (ext4_drive_Forward_Write|ext4_drive_Zone_Info|ext4_drive_Zone_Strict)
+
+enum zbd_zone_type {
+   zbd_zone_unknown,
+	zbd_zone_Conventional,
+	zbd_zone_Forward_Write_Preferred,
+	zbd_zone_Forward_Write_Required,
+   zbd_zone_reserved,
+};
+
 /*
  * This structure will be used for multiple mount protection. It will be
  * written into the block number saved in the s_mmp_block field in the
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
old mode 100644
new mode 100755
index f58a0d1..65f5f61
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -17,6 +17,7 @@
 #include <asm/uaccess.h>
 #include "ext4_jbd2.h"
 #include "ext4.h"
+#include <linux/blk-zoned-ctrl.h>
 
 #define MAX_32_NUM ((((unsigned long long) 1) << 32) - 1)
 
@@ -584,7 +585,35 @@ resizefs_out:
 		ext4_resize_end(sb);
 		return err;
 	}
+	case EXT4_IOC_REPORT_ZONES: {
+		struct gendisk *disk = sb->s_bdev->bd_disk;
+		void __user *p = (void __user *)arg;
 
+		if (!(filp->f_mode & FMODE_READ) ||
+		    !(filp->f_mode & FMODE_WRITE))
+			return -EBADF;
+
+		return _report_zones_ioctl(disk, p);
+	}
+	case EXT4_IOC_RESET_WP: {
+		struct gendisk *disk = sb->s_bdev->bd_disk;
+
+		if (!(filp->f_mode & FMODE_READ) ||
+		    !(filp->f_mode & FMODE_WRITE))
+			return -EBADF;
+
+		return _reset_wp_ioctl(disk, arg);
+	}
+	case EXT4_IOC_INQUIRY: {
+		struct gendisk *disk = sb->s_bdev->bd_disk;
+		void __user *p = (void __user *)arg;
+
+		if (!(filp->f_mode & FMODE_READ) ||
+		    !(filp->f_mode & FMODE_WRITE))
+			return -EBADF;
+
+		return _inquiry_ioctl(disk, p);
+	}
 	case FITRIM:
 	{
 		struct request_queue *q = bdev_get_queue(sb->s_bdev);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index e061e66..403d989 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3527,6 +3527,10 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		sbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,
 					       sizeof(es->s_uuid));
 
+   /* Set Media options -- Possible ZBD */
+   sbi->ext4_forward_write = (es->s_disk_layout & DRIVE_SMR)?1:0;
+   sbi->ext4_ZBD_info = (es->s_disk_layout & (DRIVE_SMR_HA & DRIVE_SMR_HM))?1:0;
+
 	/* Set defaults before we parse the mount options */
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	set_opt(sb, INIT_INODE_TABLE);
@@ -3850,10 +3854,15 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	if (sbi->s_blocks_per_group == clustersize << 3)
 		set_opt2(sb, STD_GROUP_SIZE);
 
-	/*
-	 * Test whether we have more sectors than will fit in sector_t,
-	 * and whether the max offset is addressable by the page cache.
-	 */
+   /* Does FS think it is one a ZBD device? */
+   if (sbi->ext4_forward_write)
+      set_opt2(sb, DISK_SMR);
+   if (sbi->ext4_ZBD_info)
+      set_opt2(sb, DISK_ZONE);
+   /*
+    * Test whether we have more sectors than will fit in sector_t,
+    * and whether the max offset is addressable by the page cache.
+    */
 	err = generic_check_addressable(sb->s_blocksize_bits,
 					ext4_blocks_count(es));
 	if (err) {

